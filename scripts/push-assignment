#! /usr/bin/env python3

# --------------------------------------------------------------------
import sys, os, glob, re, base64, json, configparser as cp
import datetime as dt, urllib as ul, urllib.parse, urllib.request

# --------------------------------------------------------------------
USAGE = 'Usage: %s [FILE.ini]'
URL   = 'https://vps.strub.nu/agns/%(code)s/%(subcode)s/%(promo)s/'
#URL   = 'http://localhost:8000/agns/%(code)s/%(subcode)s/%(promo)s/'

# --------------------------------------------------------------------
class Object(object):
    def __init__(self, **kw):
        super().__init__()
        self.__dict__.update(kw)

# --------------------------------------------------------------------
class Error(Exception):
    pass

# --------------------------------------------------------------------
def validate_code(code):
    if re.match(r'^[a-zA-Z0-9]+$', code) is None:
        raise Error('invalid code: %s' % (code,))
    return code

# --------------------------------------------------------------------
def validate_subcode(subcode):
    if re.match(r'^[a-zA-Z0-9]+$', subcode) is None:
        raise Error('invalid sub-code: %s' % (subcode,))
    return subcode

# --------------------------------------------------------------------
def validate_promo(promo):
    if re.match(r'^[0-9]+$', promo) is None or int(promo) < 1794:
        raise Error('invalid promo: %s' % (promo,))
    return int(promo)

# --------------------------------------------------------------------
def validate_forno(forno):
    try:
        return [int(x) for x in forno.split()]
    except ValueError:
        raise Error('invalid seq-no list: %s' % (forno,))

# --------------------------------------------------------------------
def validate_date(date):
    return dt.datetime.strptime(date, '%Y-%m-%d').date()

# --------------------------------------------------------------------
def validate_resources(resources, base):
    if not isinstance(resources, list):
        resources = resources.split()

    resources = [os.path.join(base, x) for x in resources]
    resources = [x for r in resources for x in glob.glob(r)]
    resources = [(os.path.relpath(x, base), read_file(x)) for x in resources]

    return resources

# --------------------------------------------------------------------
def validate_required(reqs):
    try:
        reqs, aout = reqs.split(), dict()
        for req in reqs:
            if ':' not in req:
                raise ValueError
            fname, indices = req.rsplit(':', 1)
            for idx in indices.split(','):
                mtc = re.match(r'^(\d+)?(-(\d+)?)?$', idx)
                if not idx or mtc is None:
                    raise ValueError
                dtc = dict()
                if mtc.group(1) is not None:
                    dtc['start'] = int(mtc.group(1))
                if mtc.group(2) is None:
                    if 'start' in dtc:
                        dtc['end'] = dtc['start']
                elif mtc.group(3) is not None:
                    dtc['end'] = int(mtc.group(2))
                aout.setdefault(fname, []).append(dtc)
        return aout

    except ValueError:
        raise Error('invalid req-files list')

# --------------------------------------------------------------------
def encode_resource(r):
    return dict(
        name     = r[0],
        contents = base64.b64encode(r[1]).decode('ascii'))

# --------------------------------------------------------------------
def encode_resources(rs):
    return [encode_resource(r) for r in rs]

# --------------------------------------------------------------------
def read_file(path, charset = None):
    mode = 'rb' if charset is None else 'r'
    try:
        with open(path, mode, encoding = charset) as stream:
            return stream.read()
    except (IOError, UnicodeDecodeError) as e:
        raise Error("error while reading file `%s': %s" % (path, e), e)

# --------------------------------------------------------------------
ASECTION = 'assignment'
CSECTION = 'auto-correct'

def read_options(filename):
    config = cp.ConfigParser()
    config.read_string(read_file(filename, 'utf-8'))

    options = Object()
    try:
        options.code        = config.get(ASECTION, 'code'     )
        options.subcode     = config.get(ASECTION, 'subcode'  )
        options.promo       = config.get(ASECTION, 'promo'    )
        options.start       = config.get(ASECTION, 'start'    )
        options.markdown    = config.get(ASECTION, 'markdown' )
        options.resources   = config.get(ASECTION, 'resources')
        options.required    = config.get(ASECTION, 'required' , fallback = '')
        options.autocorrect = None

        if config.has_section(CSECTION):
            options.autocorrect = Object()
            options.autocorrect.dir    = config.get(CSECTION, 'dir'   )
            options.autocorrect.implem = config.get(CSECTION, 'implem', fallback = None)
            options.autocorrect.forno  = config.get(CSECTION, 'forno' )
            options.autocorrect.extra  = config.get(CSECTION, 'extra' )

    except cp.Error as e:
        raise Error('cannot read INI file (%s): %s' % (filename, e), e)

    return options

# --------------------------------------------------------------------
def _main():
    if len(sys.argv)-1 != 1:
        print(USAGE % (sys.argv[0],), file = sys.stderr)
        exit(1)

    try:
        options = read_options(sys.argv[1])
        base    = os.path.dirname(options.markdown)

        options.code      = validate_code     (options.code)
        options.subcode   = validate_subcode  (options.subcode)
        options.promo     = validate_promo    (options.promo)
        options.start     = validate_date     (options.start)
        options.markdown  = read_file         (options.markdown, charset = 'utf-8')
        options.required  = validate_required (options.required)
        options.resources = validate_resources(options.resources, base)
        acorrect          = options.autocorrect

        if acorrect is not None:
            acorrect.forno = validate_forno(acorrect.forno)
            acorrect.files = validate_resources \
                (['Test_%s_%d.java' % (options.subcode, x) \
                      for x in acorrect.forno],
                 os.path.join(base, acorrect.dir))
            acorrect.extra = validate_resources \
                (acorrect.extra, os.path.join(base, acorrect.dir))

        dta = dict(
            code      = options.code,
            subcode   = options.subcode,
            promo     = options.promo,
            start     = options.start.strftime('%Y-%m-%d'),
            contents  = options.markdown,
            resources = encode_resources(options.resources),
        )

        if options.required:
            dta['required'] = options.required

        if acorrect is not None:
            dta['autocorrect'] = dict(
                forno = acorrect.forno,
                files = encode_resources(acorrect.files),
                extra = encode_resources(acorrect.extra),
            )

        url = URL % (dict(code    = ul.parse.quote(options.code),
                          subcode = ul.parse.quote(options.subcode),
                          promo   = ul.parse.quote(str(options.promo))))

        dta = json.dumps(dta).encode('utf-8')
        hdr = { 'Content-Type': 'application/json; charset=utf-8' }
        req = ul.request.Request(url, data = dta, headers = hdr, method = 'PUT')

        try:
            with ul.request.urlopen(req) as cx:
                response = cx.read()

        except (ul.error.HTTPError, ul.error.URLError) as e:
            raise Error('cannot upload assignment: %s' % (e,), e)

        sys.stderr.write(response.decode('ascii', errors='surrogateescape'))

    except Error as e:
        print('error: %s' % (e,), file = sys.stderr)
        exit(1)

# --------------------------------------------------------------------
if __name__ == '__main__':
    _main()
